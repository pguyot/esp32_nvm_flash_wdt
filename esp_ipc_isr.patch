commit 9ed1555ed7e3ce5c30120642dccceee013b9694c
Author: Paul Guyot <pguyot@kallisys.net>
Date:   Fri May 19 19:01:41 2023 +0200

    Fix a race-condition in esp_ipc_isr
    
    The race condition is very unlikely on real hardware but can be observed with
    qemu under heavy load.
    Also add missing `memw` instructions which are generated by the C compiler but
    absent in the assembly code.
    
    Signed-off-by: Paul Guyot <pguyot@kallisys.net>

diff --git a/components/esp_system/port/arch/xtensa/esp_ipc_isr.c b/components/esp_system/port/arch/xtensa/esp_ipc_isr.c
index 70fb1a9f1f..40edd3958b 100644
--- a/components/esp_system/port/arch/xtensa/esp_ipc_isr.c
+++ b/components/esp_system/port/arch/xtensa/esp_ipc_isr.c
@@ -54,6 +54,7 @@ typedef enum {
 #define IPC_ISR_EXIT_CRITICAL()  portEXIT_CRITICAL_SAFE(&s_ipc_isr_mux)
 
 static void esp_ipc_isr_call_and_wait(esp_ipc_isr_func_t func, void* arg, esp_ipc_isr_wait_t wait_for);
+static void IRAM_ATTR esp_ipc_isr_wait_for_end();
 
 
 /* Initializing IPC_ISR */
@@ -142,6 +143,8 @@ void IRAM_ATTR esp_ipc_isr_release_other_cpu(void)
         const uint32_t cpu_id = xPortGetCoreID();
         if (--s_count_of_nested_calls[cpu_id] == 0) {
             esp_ipc_isr_finish_cmd = 1;
+            // Make sure end flag is cleared and esp_ipc_isr_waiting_for_finish_cmd is done.
+            esp_ipc_isr_wait_for_end();
             IPC_ISR_EXIT_CRITICAL();
 #if CONFIG_FREERTOS_SMP
             portRESTORE_INTERRUPTS(s_stored_interrupt_level);
@@ -191,7 +194,7 @@ static void IRAM_ATTR esp_ipc_isr_call_and_wait(esp_ipc_isr_func_t func, void* a
     const uint32_t cpu_id = xPortGetCoreID();
 
     // waiting for the end of the previous call
-    while (!esp_ipc_isr_end_fl) {};
+    esp_ipc_isr_wait_for_end();
 
     esp_ipc_func = func;
     esp_ipc_func_arg = arg;
@@ -213,8 +216,13 @@ static void IRAM_ATTR esp_ipc_isr_call_and_wait(esp_ipc_isr_func_t func, void* a
         while (!esp_ipc_isr_start_fl) {};
     } else {
         // IPC_ISR_WAIT_FOR_END
-        while (!esp_ipc_isr_end_fl) {};
+        esp_ipc_isr_wait_for_end();
     }
 }
 
+static void IRAM_ATTR esp_ipc_isr_wait_for_end()
+{
+    while (!esp_ipc_isr_end_fl) {};
+}
+
 /* End private functions*/
diff --git a/components/esp_system/port/arch/xtensa/esp_ipc_isr_handler.S b/components/esp_system/port/arch/xtensa/esp_ipc_isr_handler.S
index 0fb4ae676a..20638a6895 100644
--- a/components/esp_system/port/arch/xtensa/esp_ipc_isr_handler.S
+++ b/components/esp_system/port/arch/xtensa/esp_ipc_isr_handler.S
@@ -96,6 +96,7 @@ esp_ipc_isr_handler:
 
     /* set the start flag */
     movi    a0, esp_ipc_isr_start_fl
+    memw
     s32i    a0, a0, 0
 
     /* Call the esp_ipc_function(void* arg) */
@@ -113,6 +114,7 @@ esp_ipc_isr_handler:
 
     /* set the end flag */
     movi    a0, esp_ipc_isr_end_fl
+    memw
     s32i    a0, a0, 0
 
     /* restore a0 */
diff --git a/components/esp_system/port/arch/xtensa/esp_ipc_isr_routines.S b/components/esp_system/port/arch/xtensa/esp_ipc_isr_routines.S
index 01ddf8b528..e947c3ed2f 100644
--- a/components/esp_system/port/arch/xtensa/esp_ipc_isr_routines.S
+++ b/components/esp_system/port/arch/xtensa/esp_ipc_isr_routines.S
@@ -23,6 +23,7 @@
 esp_ipc_isr_waiting_for_finish_cmd:
     /* waiting for the finish command */
 .check_finish_cmd:
+    memw
     l32i    a3, a2, 0
     beqz    a3, .check_finish_cmd
     ret
